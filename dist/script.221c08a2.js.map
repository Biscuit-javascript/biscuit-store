{"version":3,"sources":["../packages/biscuit-store/src/internal/repositories.js","../packages/biscuit-store/src/internal/debugger.js","../packages/biscuit-store/src/internal/messages.js","../packages/biscuit-store/src/internal/emitter.js","../packages/biscuit-store/src/internal/helper.js","../packages/biscuit-store/src/internal/dispatch.js","../packages/biscuit-store/src/internal/utils.js","../packages/biscuit-store/src/internal/store.js","../packages/biscuit-store/src/internal/creator.js","../packages/biscuit-store/src/index.js","script.ts"],"names":["repositories","states","middlewares","settings","strictMode","debugCollection","writeLog","type","message","repoName","Object","keys","length","line","stack","split","createLog","name","file","level","repo","data","key","Log","Error","constructor","call","Warning","console","warn","CreateError","messages","noRepo","noState","initialType","noListener","noValidAction","storageNameError","fnName","noStoreParams","noRepoName","middleNoFunc","debuggerNoFunc","actionString","repoNotFind","repoExists","createEmmitor","taskBuffer","subscribeAction","taskName","listener","state","task","todo","id","params","remove","splice","subscribeActions","actions","tasks","action","push","dispatchAction","forEach","undefined","emitter","getStateRepo","getRepository","content","getRepositoryActions","getRepoName","target","actionError","activeMiddlewares","context","fn","middle","payload","gettter","instance","freeze","compareObject","firstState","lastState","propInFirst","propInLast","prop","dispatchProto","prev","payData","before","merge","after","resolve","Promise","then","dispatchInitMiddleware","getAction","actionName","newPayload","throttle","callback","limit","waiting","apply","arguments","setTimeout","debounce","isCooldown","sandbox","run","throt","initialThrottle","timer","throttleCaller","args","memoize","cache","n","result","value","regex","matches","prototype","toString","match","toLowerCase","subscriber","promise","getState","getRepo","addRepo","dispatch","voids","wait","subscribeToState","that","e","reject","subscribeToStore","createManager","pull","replaceRepo","replaceState","mergeState","targetAction","item","compareStates","compareWithState","compareStateWithInstance","compareRepoWithInstance","clone","update","props","newRepo","initial","subscribe","get","add","createStateTo","createNewState","stns","branch","bind","options","actionStr","actionParams","returnedParams","initialActions","createActions","map","stateCollection","collection","compile","all","fromRepo","outOfState","stateName","out","filter","combineStateCollections","collections","allState","sc","middleware","store","s","createDebuger","createStore","createAction","output","param","paramType","debugger"],"mappings":";;;;;;;ACCA,AEDA,ADCA,AFDA;AKAA,AHEO,AFDA,MECM+B,AFDA/B,QECQ,GAAG,CFDC,GAAG,EAArB;ACEP,AEFA,ADEIgC,AFDJ,EECIA,MAAM,EAAGf,IAAD,IAAW,eAAcA,IAAK,cADlB;ADEjB,AIHP,AHGIgB,AIJJ,EJIIA,IDAS5B,GCAF,EAAGY,IAAD,IAAW,EDAI,GAAG,EAAxB,GCA0BA,IAAK,cAFd;ADIxB,AEJA,ADGIiB,AIJJ,EJIIA,WAAW,EAAE,gCAHO;ADKxB,AILA,AFCA,ADGIC,AFHG,AMDP,EJIIA,IFHSlC,MEGC,AFHK,EEGH,CFHM,EAAf,6CEDiB;ADMxB,AEJA,ADGImC,AFHJ,AOJA,ADGA,EJIIA,aAAa,EAAE,wCALK;AMFxB,APSA,AINO,AFEP,ACLA,AFQIC,AIJJ,EJIIA,OGLYmD,SHKI,EAAGlD,EGLhB,CAAuB,GHKR,IACb,WAAUA,MAAO,uCAPF;ADQxB,AIPgCuB,AFGhC,ADIItB,AKNJ,ADCA,EDFgCsB,AHO5BtB,MGP0B,OHOb,EACf,6DATsB;AMDxB,AHEwCkD,AFIxC,ACNA,AFWIjD,AFPG,AMCP,EDHwCiD,AHSpCjD,IGT0B,ALEjBtC,MEOC,EAAE,GFPQ,GAAG,EAApB,kCEHiB;AGCsBwF,AFK9C,ADKIjD,AFPJ,AOCA,ADAO,EDJuCiD,AHU1CjD,OCLKK,AGDOuD,KJMA,EAAE,CINX,CAAkBC,IHCzB,GAAyB,CGDlB,EAA4BC,KAA5B,EAAmC,0BJLlB;AMMxB,AHL8B,AFM1B,ACPJ,AFYI7D,AINA,CDLG,CHWHA,CGXqD,GCKjD8D,EHCEzD,KGDK,GJMG,AINA,EHCE,ADKA,GCLG,AGDnB,EHCA,sCDPoB;ADSxB,AIPI,AFOA,ADIAJ,AKAJ,ADNI,EJMAA,IDJErC,GEAK,AGFA,KLEG,ACIE,EAAE,CDJD,IKFM,MLEIC,IAAV,EAAgBC,OAAhB,EAAyBC,QAAzB,ACTO,EDS4B;AOKpD,APJI,AIPJ,AFOQ,ACRD,AFYHmC,AFTG,AMGC,EJMJA,IDJIlC,ADLKP,EMGD,CFNIgE,AEMHqC,GLEC,CAAC7F,ACIA,CFTM,CESJ,CINT,CLEA,ADLgB,CCKJN,AKFE,GFNf,CAAsBwD,MAAtB,EAA8B,GHQ7B,EAA6BjD,GCVb,GDUhB,GAAsC,CAA1C,EAA6C;AACzC,AIPR,AFOA,ACRI,AFYAiC,AFTAzC,AOQJ,ADLYkG,EJMRzD,AFTAzC,IMGQkG,GFNDrG,CHQGY,ECIA,AFTA,ECKI,ACIF,AFTA,AMGI,CAAC4F,ELEA,GKFT,CAAe,CLED3F,GKFd,ELES,AKFY4F,CLED3F,EGRb,GHQE,CAAiB,AGRhB8C,EEMV,ELES,EAAuB,AGRhB,CHQP,AGRQV,EHQkBpC,GGRZ,EHQd,CAAgC,AGR1C,EAA4B8C,CHQlB,EAAqC,CAArC,CAAb,CGRqC,CAACzC,IAAnC,CAAP;AIYJ,APHQJ,AIPR,AFOA,ACRC,AFJuB,AFKA,AMKZwF,CJVL,AFKA,GCOCxF,EKFIwF,OLEK,AKFE,CLGP,EKHU,IAAV;ALIIhG,AIRhB,AFOA,AIEA,ADJYmG,MLGInG,AKHJmG,OLGW,EAAE,CKHH,CAAC,GLGO1F,GKHD,CLGJ,GAAY,IAAZ,GAAmBT,OADhC;AOGZ,APDgBU,AIRZ,AFOJ,ACRO,AEMSsF,MLGAtF,CIRPyE,CCKOa,CFNApC,CHSI,EAAEvD,CIRlB,ECKmB,CLCX,AINO+D,EAAD,ACKQ,IDLA,ADDnB,CAAuB3D,AEMd,IFNT,EAA6B;AHUpBE,AIRRyD,AFOR,ACRI,AGSJ,ADHa,IDLLA,EJQQzD,AIRN,CAACsE,ACGW,EFJXzF,AEMIuG,ELGM,AIRX,CAAF,CJQe9F,CKLD,CAAV,MLKmB,GAAG,OAAH,GAAa,EGTpBQ,IAAb,EHMC,AGNkBoD,OAA1B;AIWJ,APDgBjD,AIRR,AFOR,ACRC,AEMQ,MLGOA,IAAI,CIRL,CJQOX,GIRd,KJII;AOMZ,APDgBF,AIRX,AFOL,AIAA,ADFK,GDRD,ACAA,GLWYA;AOEhB,APPY,AIDR,AFMJ,ACRO,AEMN,KLJgB,EAQLE,EGVI6D,MHEC,CAAT,aGFD,CAA8BlD,IAA9B,EAAoC;AIW3C,APCK,AITL,AFMA,ACRI,AGOJ,ADAA,SFPWpB,2BAAaoB,IAAb,EAAmBuC,OAA1B;AIWJ,APCC,AITD,AFMQX,ACRP,AGOD,ADAA,CLVA,GEWQA,eAAe,EAAE,CAACC,QAAD,EAAWC,QAAX,EAAqBC,KAArB,KAA+B;AKGxD,APEA,AIVA,AFMY,AIDZ,ADAA,UHCgB,OAAOD,QAAP,KAAoB,UAAxB,EAAoC;AKGhD,APEA,AEJgB,ACRT,AGOP,ADAA,SFPgBqB,KDQM,IAAIzC,ECRnB,CAAqB0C,MAArB,EAA6B,UDQd,CAAgBzC,mBAASI,UAAzB,EAAqCc,QAArC,CAAN;AKGhB,APEA,AEJa,ACRT,AGOJ,ADAA,MFPQ,OAAOuB,MAAP,KAAkB,QAAtB,EAAgC;AIW7B,APEP,AIZI,ADAI,AGOR,ADAA,ODPSoB,EGUO+D,EJVDnF,CCAX,GAAa,CGUV,CAAiBvD,AJVhB,IIUD,AHVgB,EGUO2I,OAAO,GAAG,EAAjC,EAAqC;AACxC,APEJ,AIZQ5J,AFQI,ACRP,AGOL,ADAA,MEGQ,CAACiB,GLFO,CKEZ,ALFa8B,EKEF,QLFY,CAACE,QAAD,CERNY,AFQT,EAA2B,IERZ,CAACzC,IAApB,EAA0BiD,OAA1B,GAAoC,EAChC,GAAGoB,IAD6B;AGWpC,APER,AIXY,AFOI1C,AIDhB,ADAA,QHCgBA,CEPD2C,CGSD,IAAI5D,ILFQ,CAACmB,QAAD,CAAV,GAAuB,EAAvB,EKEF,CAAgBlB,mBAASS,UAAzB,CAAN;AACH,APEL,AId4C,AFU/B,ACRT,AGOJ,KFTQ,CESFwF,GHPKxD,MAAM,CAACpD,AGOF,GAAG,CHPf,SGOyBA,IAAV,EAAgBwD,EAAhB,EAAoBzB,KAApB,EAA2B;AFJtC,AFMI,ACRX,AGOG,MAAIC,IAAJ,CFLW,IAAP;AGSJ,AHRC,AEKD,ADFG,GDVH,GGeI,EDHE6E,CDFMrB,IEKD3F,EDHE,ECGT,AFLD,CCEa,ADFKqF,IEKD,ADHAP,IDFjB,EAA4BQ,CCEf,CCGhB,ADH6BT,ECGC,CFL3B,EAAmC,ECEV,IAAa;ACIrC,APAD,AIPH,ADHG,AGOC1C,ADFJ,ICEIA,ENGKpC,AGVAyD,AEKLoC,ECEI,ECGE,CDHC3C,GCGGpC,CPAI,CKLJ,CFLM,CHUC,CKLJ,CFLO+B,IEKxB,EFLuB,EHUQxC,AMHZ2B,EHPgB,EHUd,EAAgBvC,COA3B,CAAgBsB,MPAL,CMHV,CNGoC,AMHZX,IAAxB,EAA8B,KCGNiB,CDHY,eCGrB,CAA0B,SAA1B,CAAhB,CAAN;AACH,APAD,AIPJ,AFGY,ACNR,AGOQ,ADDR,MFNI,CHUC,AGVAwB,EEME,GHAOT,CFIH9B,AGVP,GHUJ,AEJkB,CCNH,CAACuC,CDMK,CFIHxD,CKJC,GFNG,CAACe,IAAnB,IAA2B,CAACyC,CHUhC,EAAmC,GGVG,CAACV,KAAvC,EAA8C;AHW1C,AIPR,AFGgBA,ACNR,AGOI,ADDJ,QLII7B,AEJI6B,AGAJ0D,EFNE,CHUC,CMHGxF,CJFO,CCLPS,EHUErB,AMHE,EDDd,CCCiB0C,CDDD,ILIhB,AMHsB,ENGA,CMFZ+E,QHRJ,AGQY,CHRI,AGQH,4BHRb,CAAN;AIWJ,APAQ7H,AIPZ,AFGgBY,ACNX,AGOwBG,ADDjB,MEIJ,APAIf,EEJIY,AICaG,IJDT,AICO,EJDL6B,OFIK,CAAC3B,AENH,CKMZsI,EPAc,CAAf,CAAqBvI,GOAzB,CPAI,KOAc,QAAtB,EAAgC;AAC5B,APAC,AIPT,AFGgBgC,AIAmBF,ADA1B,QHAOE,AIAmBF,ECIrB,ELJM,EKIFrB,ALJIoB,QAHG,aKOX,CAAgBnB,mBAASG,WAAzB,EAAsCjB,IAAtC,CAAN;AACH,AHPL,AFGgBqC,ACNZ,AGKuB,MHLnB,CAACtD,AGKiB,CJCVsD,AIFc,EJEZ,CIAA6E,CJAEpF,MIAK,CAAC3B,GJAI,CAAC6B,AIAN,CAFb,OJEkB,CAAV,CAAqBrC,CCNnBiD,MAAM,CAACzC,IAApB,CAAL,EAAgC;AHW5B,AETiB,ACDjB,AGMIwD,ADDJ0B,IAAAA,ECCI1B,CJLA,CFSA,AMJE,CNIDnE,AMJEY,CHND,EEKE,CCCF,ADDGoF,CFLC3E,CGMGsB,ENIb,CKLA,CLKe,AMJT,ADDS,CCCX,GDDJ,EAAqBsD,SAArB,CFLM,CAAgB3E,mBAASC,MAAT,CAAgB6B,MAAM,CAACzC,IAAvB,CAAhB,CAAN;AIWJpB,APAQK,AEJA,ACNP,AGMOyF,ADDJe,IAAAA,ELKIxG,AMJAyF,OAAO,CAAC,ADDF,GAAG,ILKM,AKLnB,CLKoBxE,GAAD,CAAf,CAAqBD,EOAhBJ,EPAL,EOAR,IAAqB;AAAEoD,APClB,AITL,AEIkBhD,ADAdsF,IEImBtC,AFJnBsC,GDJCd,CEIaxE,GCIY,CHR9B,CGQgCuI,CFJlB,CDJD,ACIE,KEIM,CHRDhF,ACICiC,EDJR,IAAc,ICII,GAAG,KAApB,EAA2BN,KAA3B,CAAV;AEIqC5C,APExC,AITG,AFIIZ,ACLR,AGIgB,ADCf,GAPD,CEUyCY,ELHjCZ,ACLJ,CAAC9C,AGIU,CFHPmD,AEGA,GCIwC,CHP5C,CGO8C,GLHhC,CAACA,IAAI,CAACnC,IAAN,CAAV,CAAsBmC,ACLjB,IDKqB,ACLlBS,CDKmBP,EAA3B,GCLc,CDKmBF,ACLlBD,IDKf,CCLqB,GAAxB,CAAL,EAAkC;AIQb,APGxB,AEJW,ACNJ,AGIC,ADCR,CLLM,EOOH,EDVW,EAOJA,GJEK5B,ACNF,EGHC,CAAP,CHGUO,SDMN,CAAS,WCNP,CAAgBC,WDMakB,QAAS,ACNbhB,OAAT,CAAiB4B,IDMgBV,ECNV,CAACA,EDMe,EAAzD,CCNkB,CDM0CF,ACN1D,EAAgDY,MDMlD,ACNwD,CAACzC,IAAvD,CAAN;AISJ,APGJ,AIXQ,AFMI,ACNP,AGIA,ADEL,GCXoB,CAAhB,KCaO,CHRGM,GFMK,CEND,GAAG,UAAUoE,OAAV,EAAmB;AGShC1E,APGR,AIXY0E,AFMI,ACNf,AGKG,ADCJ,CFlBO,GIoBC1E,EHRI0E,EGQA,ADHFA,ECGI7E,GHRK,CGOR,AHPS,CEKH,CFJD,EEII,CFJD,IEIM6E,OAAL,CAAamC,OAAb,CAAhB,MFJ4BpE,MAAb,EAAqBQ;AJWxC,AIZoB,AFOJd,ACLhB,AGIIuC,ADCJ,ECDIA,KFNe,CAAP,AFOIvC,CIDL,CAAC,IJCU,EAAEH,IAFL,GICR,CAAP,GAAyBA,IAAI,CAACI,MAA9B;ACGI,APIR,AIVYJ,ADAZ,AGKI,ADAJ,MDLYA,GEKD0C,CFLK,CAACtC,KEKb,CFLQ;AGOJqG,APIR,AIVS,AFIO,ACJhB,AGKC,ADAD,CCjBA,GCkBQA,CHXA,QGWS,EAAGjF,EAAD,IAAQ,6BAAiB3D,IAAjB,EAAuB2D,EAAvB,CAHhB;APQX,AENA,ACJA,AGMA,ADDA;AECQ,AHLA,AFIR,ACJA,AGMA,ADDA,UDLc,IAAImB,OAAJ,CAAaD,OAAD,IAAa;AGM/BgE,AHLI1G,AFIII,ACJhB,AGMA,ICDQsG,EHLI1G,CGKD,CLDKI,CKCH,CHLG,GAAGU,CFIG,CKCH,CLDK,MAAM,QEJHlB,KGKA/B,IAAR,CALR,KHAQ,CACH4C,MAAM,CAACzC,IADJ,EAEH,MAAMM,IAAI,CAACoE,OAAD,CAFP,EAGHjC,MAAM,CAACV,KAHJ,CAAP;AAKH,AFAW,ACJpB,AGMA,KFRc,EAMH6C,IANG,CAMEpB,EANF,AFMUrD,CENhB,YFMY,CACK,yBAAwB6B,IAAI,CAACnC,IAAK,YAAWmC,IAAI,CAACD,KAAM,EAD7D,EAEIC,IAAI,CAACnC,IAFT;AKCZ,AHAA,AFGY8B,AIDpB,ADHO,MAAM+D,IHIO/D,CEHL,ECDK,EDCZ,CCDgB6B,EAAD,EHIO,CAACxB,CGJA,GHII,CAACnC,IAAN,CAAV,CAAsBwC,MAAtB,CAA6BL,IAAI,CAACE,EAAlC,EAAsC,CAAtC;AKFZyG,APED,AIFF,AFGY,AIDjB,ADHI,GDhBA,CGiBIA,EPEKxI,COFF,EAAGyD,APEP,AKHI,QECE,CPEYxD,GOFE,EPEpB,CAAwB,iBOFIP,IAAR,EAAc+D,QAAd;AAPhB,APUPvD,AIFH,AFVkB,AIYnB,ADHQsF,ELGJtF,COVA,CFOIsF,GHTI,AGSD,EAAG,ILGC,CAACvG,OAAD,AKHW,ELGDC,QAAV,EAAoB;AODlC,APEO,AECC,AGJG,KHxCD,KF2CGD,AKHEwG,KAAK,ELGb,CKHgB,IAAZ;AEGZ,APCQ,AIFD,ADRA,AEQK,SLEC/F,IAAL,EIFcgF,ADRAvB,CHUF,aAAZ,GGVD,CAAiCC,ICQjC,CAAsC,EDRtC,EAA0CC,EAAE,GAAG,MAAM,IAArD,EAA2D;AIUlE,APCQtE,AIHuCuD,AFIvC,ACXJ,AGQG,ADAP,EDD+CA,EJGvCvD,EGVAJ,ECOqC,CEC7BkI,GNEA,CAAC1G,GMFV,CNEC,AMFgB8C,CNEF,IAAd,CMFD,CNEqB,CMFIQ,INExB,EAA2BxE,CGVfmE,CGQb,EAAmC,GNElC,CGVmB,CHUiBlE,AGVhBW,IAApB,CAAJ,EAA+B,CHU3B;AOAR,APCK,AIJkDsE,AFKvD,ACXQ,AGQJ,ADAJ,EDFuDA,MEE7CzE,CFFmC,CDN/Bf,EGQA,GAAG,qBHRSyE,IGQGH,GHRI,CAACpD,EGQjB,CAAb,CHRU,EAA0B4C,OAA1B,CAAmCa,MAAD,IAAY;AIU5D,AHJgEY,AFMhE,ACXYZ,AEQZ,EDHgEY,IDLpDZ,MAAM,CAACF,OAAD,EAAUC,EAAV,CAAN;AIUZ,APN+B,AICc,AFO7C,ACXS,AGOL,CFHG,EAAiE,EDN1D,CAAN,AGSA,CAAC5E,2BAAaiB,IAAb,CAAL,EAAyB;ACG7B,APCA,AINI,AFOJ,ACXK,AGOG,ADAI,GFXR,KCQM0C,CDJC,CGOG,EDAIsD,ECAAnF,CFHD,GAAG,SCGa,GAAG,CAACJ,ICAvB,ADAsB,CCANK,CDAamF,KAAP,KAAiB,KDHZrD,GEGF7B,GFHQ,CAACZ,EEGlB,CAAgBH,CFH1B,CAAhB,EEG0B,CAAhB,CAAN;ACGR,APCA,AINI,AFOJ,ACXQ2D,AGOH,ADAW,IFPRA,EAAE,CAACD,ECIA,GCGS,CAACqC,CFPH,CCID,ADJElC,GEOH,CDHKiB,CCGO,EFPlB,CAAF,GCIS,CAAaD,OAAD,IAAa;AJO1C,AINQ,AFOR,ACXK,AEOekB,UAAAA,KAAK,GAAGpC,EAAE,CAAClD,IAAD,EAAOwF,KAAP,CAAV,EDFR;AJMZ,AILgBrD,AFMRH,ACXP,AGOG,ADAa,IHITA,EENQG,AEER,MFFc,EAAEA,MAAM,AFMN,CENOV,CFML,CAACQ,AIJdqB,GFHD,IFOc,CIJlB,CJI4B9B,KIJT,GJID,KAAuB,AIJ7C,EAAiC;ACC9B,APGP,AILgB9B,AFMJ,ACVZ,AGMQ,ADAK,MDFGA,CCFJ,EEII4I,CHFI,AFMJ,AIJF,EFFQnG,EEEJ/B,GJIKoB,CENK,CAAC9B,GGEtB,CAAuBmC,AHJlB,EFQI,IKJT,CLI6B,CKJE,IDAxB,CAAgBxB,IJIlB,EAAoC,aIJTG,WAAzB,CAAN;ACCJ,APGJ,AILgB4C,AFMA,ACVhB,AGMK,ADCO,MEDJ,AHFQA,CGEP9E,MHFc,CFMD,CENG0F,GFMC5D,IETd,YGKUyB,KLIA,CKJM,ALIUxB,CKJTX,IAApB,CAAL,EAAgC,WLIWe,UAAzB,CAAN;AKHR,AHFQgB,AFMH,ACVb,AEOA,MDHgBA,IGEF,CHFO,EAAEsC,CGEL3D,GHNN,kBGME,CAAgBC,mBAASa,WAAzB,CAAN;AACH,AHFWsD,ADJhB,AGMIlG,ADCJ,MDHgBkG,SAAS,EAAGC,UAAD,EEEVlF,EFF0B0C,EEEvC,EAAmBU,GFF2B,CAAE,GEEhD,CFFmD8B,EEEtB,EACzB,GAAG,GFHuD,GAAhB,qBEGzBlF,IAAd,CADsB;AFPrB,AFYA,ACVZ,AGOQ,ADAR,KDVQ,EAQKmF,AEEFpB,KJGOpB,KELN,AFKW,GAAG,CELE,CFKhB;AKHR,AHDYkC,ADLhB,AGIiC,GAA7B,GFCYA,EGCNmE,KHDa,CAAC7D,QGCA,EHDU,CGCN8D,GHDUxE,CGCX,IAAU,EHDd,CAAP;AGER,APDD,AIAM,AFID,ACTZ,AGOC,KFZO,CJUK/D,EOCD,CAACuI,ELGI,EKHA,APDV,COCWC,GLGKtG,GKHf,EAAkB,APDGrC,CEIjB,IFJL,AEI0BmC,CFJE,MEIvB,EAA8B;AKF9B,APDRlC,AICC,AFGW,ACThB,AGQA,ADHY,ELARA,CIZa,CAAb,QFgBgBF,AGJF4F,CECCnH,APDJ,CAACQ,OAAD,EAAUC,EEIT,CACK,AGLW,GAAG,CAAC,CLArB,EAAoB,AKAI2G,IAAJ,GECH7D,EFDgB,IECV,CAACnC,ELIIyC,EKJxB,CAAP,GLIqC,CAACzC,IAAK,YAAWyC,MAAM,CAACV,KAAM,EAD/D,EAEIU,MAAM,CAACzC,IAFX;AKFP,APDD,AICP,AEED,ADHgB,ULAFZ,KKASwG,ELAf,GKAoB,CAAC,GAAGI,IAAJ,CAAZ;AHQA,AIJhB,ADHa,OAFD,KHSQ,CAACvD,MAAM,CAACzC,IAAZ,EAAkB;AKL1B,APDA,AEOY,ACdb,AGUP,ADFY,QLDAjB,CGPI4E,EIQD,KLMW,ACdnB,CAAiBC,GDcMlD,KCdvB,EAA2B,IHOb1B,UAAT,AEOc,CFPMK,AEOUsB,QFP9B,CAAJ,EAAmC,QEOQK,aAAzB,CAAN;AKLRiC,APDA,AEOK,ACdb,AGUJ,ADFA,MEAYA,GJRD3D,IIQQ,EAAE,AJRJ,CAACuE,CISF,GAAGjF,EJTR,CAAc,EAAE,GAAGgF,mBISEzB,MAAM,CAACnC,IAApB,EAA0BiD,OADxB;AAEL,APFJzC,AGRa,AGWzB,ADFA,GFTW,CAAP,EHQQA,KOEOsI,EPFA,CAACrI,COEG,CAAC+H,EPFZ,CAAapJ,OAAb;AOAS,APCZ,AEOO,ACff,AGWD,ADFA,YHMoB,CAACuC,UAAU,CAACc,MAAM,CAACzC,IAAR,CAAf,EAA8B;AKT/B,ALUK2B,ACdpB,AGUA,ADFA,KEJQ,KLUYA,UAAU,CAACc,MAAM,CAACzC,IAAR,CAAV,GAA0B,EAA1B;AKJf,APFG,AEOS,ACdjB,AGUA,GCZI,MPSSH,IAAL,GAAY,cAAZ;AACAX,AEOQ,ACdhB,IHOQA,QAAQ,CAACoB,IAAT,CAAc,IAAd,EAAoB,SAApB,EAA+BlB,OAA/B,EAAwCC,QAAxC;AOGJ,APFC,AGPL,AEMY,SEGD,IFHQ,CAACiB,IAAD,EAAOwF,KAAP,KAAiB;AEI5B,AJTR,AGQO,ADFSD,QAAAA,CCEAkB,OAAT,CAAiB3D,MAAjB,ADFwB,CAAC9C,CCEA,GDFD,EAAOwF,KAAP,CAAf;AEIhB,APfmC,AEkBnB,ACZhB,AGQI,ADFY,QCENjG,IAAI,EJIQmC,CIJL,ADFM+D,GHMG,GAAG,QGNb,WCEa3C,MAAZ,CAAb;ACEJ,APFA,AEKoBrB,ACZpB,AEMa,OAHD,GHSQA,KAAK,EAAEU,MAAM,CAACV,KADL;AKD7B,APFA,AEKoBlC,ACZpB,AGQI,ADFK,KA9BI,CCgCL,CAACjB,GJIWiB,IAAI,EAAE4C,MAAM,CAACzC,IAFJ,OIFPH,IAAb,CAAL,EAAyB;ACE7B,APFA,AEKoBoC,AIJZ,ADlCG,GAAP,OHsCgBA,AIJN,IJIU,AIJNvB,EJIQoB,QAHG,WIDf,CAAgBnB,mBAASC,MAAT,CAAgBf,IAAhB,CAAhB,CAAN;AEnFR,ADqFA,APFA,AEKoBqC,AIJf,ADFJ,CAlCM,SHwCaA,EAAE,EAAEP,UAAU,CAACc,MAAM,CAACzC,IAAR,CAAV,CAAwBR;AKFxCwJ,APFR,AEA6B,ACTtB,AESP,IEEQA,IAAI,CLFI,ACTAlF,CIWF,CAACrB,MAAD,EAASwG,GJXhB,CAAuBlF,GIWA,GAAG,IJX1B,EAAmCC,SAAnC,EAA8C;AKhErD,AD2EmC+E,APDnC,AEKgB,ACdZ,AGUA,ADDJ,MECmCA,AJV3B9E,GGUG,GCA8B,EAAE,GJVxB,EIUc,CJVX,CAAlB,SGUe,EAAE,GAAG,2BAAcpE,IAAd;ACA0B2I,AJT9C,AGSe,ADAnB,GCAW,CAAP,ECA8CA,AJT1CtE,OISiD,EAAE,CJTzC,GAAG,CAAjB;AIS6B,ALKjBvC,ACbZ,AGSH,ADAD,KEDc,CJRNwC,EDaQxC,EKLoD,AJRhE,QDasB,CAACK,IAAI,CAACnC,IAAN,CAAV,CAAsBmC,IAAI,CAACE,EAA3B,IAAiCF,IAAjC;AKJJ,ALKI,AIHhB,ADDA,UEDgB,OAAOS,MAAP,KAAkB,QAAtB,EAAgC;AAC5B,ALKhB,ACbI,AGUJ,MHVQsB,QIQc,EJRJ,EIQQrD,GJRHsD,SAAnB,EAA8B,OIQZ,CAAgBrD,mBAASY,YAAzB,EAAuCY,MAAM,CAACnC,IAA9C,CAAN;AACH,APHN,AGLC,AGUR,MNLaU,KGLE,IAAP,EHKD,SAA0BN,KAA1B,CAAgC;AACnCC,AEOYmC,ACZX,AGUL,ENLInC,MEOYmC,KFPD,AEOM,CFPLpD,AEOMsD,IAAN,CAAWV,EFPZ,EAAU3C,AEOT,QFPD,EAAoB;AOIvB,APHJ,AEOK,AIFb,UNLcD,EOGI8J,KPHV,IOGmB,GAAI,IAAGzG,MAAO,GAA7B;AAEA5D,APJJ,AGLJ,AGUJ,ADLO,MFJCkF,AEIKkC,GLAApG,IAAL,AKAY,GLAA,AGJF,AEIM2D,EAAD,GFJA,CEIQ,GFJvB,EIQW0F,EJPjB,EHGM,KOII,AJPHnF,IIOuB,EAChB,GAAGlF,CJRjB,KAAsB,QADhB,IAENmF,GIOwBkF,MJPf,GIOQ,CADa,CJNhB,IAFR,IAGN,OAAOlF,SAAP,KAAqB,QAJnB,EAKE;AIMU,APLR9E,AEOI,ACPJ,AGKR,ADLI,ILAIA,IKAEgH,CEKO/D,EJLF,CHAC,CAAC7B,AEOE,AGPJ,EEKQ,CAACN,AJLhB,AEAU,CLAV,CAAc,AKAlB,EEKY,EPLR,COKuB6I,CPLH,OAApB,EAA6BzJ,IOKQ,CAAC6J,EPLtC,EAAsC5J,GOKD,KPLrC;AOGwB,APF3B,AEOW,ACPX,AGKL,ADLI,OEEQ,EFFD,CAAC,GAAG2G,IAAJ,KAAa;AEOZ,ALCI7D,AIFhB,ADLQ,QHOQA,EGPFgE,CAAC,CEMGgD,ELCI,AGPJnD,EHOMxD,EGPF,CAAC,CAAD,CHKH,AGLX,GEMsB,GAAG;AACjBxC,APbuB,AGOnC,OAAKmE,CIMOnE,GJNZ,CIMgB,EAAEmC,CJNL4B,KIMW,CAAC/D,IADI,AJL7B,EAAyB;AIOb+B,ALAA,ACNRkC,AEDA,IFCAA,IIMQlC,AFPJoE,CAAC,IEOQ,AFPJD,EEOMzD,AJNJ,GEDX,CFCe,CAAf,AEDgB;AEKS,ALGjC,ACNK,AGGE,ADJK,OEIA,EDAIqE,IDJGZ,ICIZ,CAAkBzD,ADJD,CAAC0D,CAAD,CAAZ,GCIL,EAA0B;ACKrB,ALDZ,AIHI,ADJK,KAFD,MAEO,CEQGiD,cAAc,CDJhB3G,ECImB,EACnB,EDLZ,CCKe0G,YADgB;ALAnB/G,ACNZ,AGGA,ADJQ,OFCH+B,CDMO/B,CIHL,EHHP,CEDcgE,EHOI,CCNLpC,CDMO,EGPA,GAAGR,CHOG,CGPD,CFCzB,AED0B2C,CAAD,CFCD,AEDhB,ICIO,EAAE,GAAG,0BAAa1D,MAAb,EAAqBQ;ACK7B,ALDI,ACNZiB,AGEW,ADHPgC,GCGD,CHFHhC,AGEJ,EDHQgC,KAAK,CAACC,CAAD,CFCC,AEDN,CHOa,EGPFC,CFCD,CAAd,EDMuBpE,EGPnB,EHOQ,IAAmBQ,KAAnB,EAA0B;AKE9C,ALDwB,AIJvB,ADHW,aAAO4D,GHOSjG,GGPhB,UHOY,CACK,yBAAwB6B,IAAI,CAACnC,IAAK,YAAWmC,IAAI,CAACD,KAAM,EAD7D,EAEIC,IAAI,CAACnC,IAFT;AKExB,ALEwB8B,ACThB,AGGR,ADJS,QFEG,EAAEwC,EDQUxC,ECRN,IAAIoC,IDQY,CAAC/B,IAAI,CAACnC,ACR5B,IDQsB,CAAV,ACPrB,CDO2CwC,ACP1CyB,MDOoB,CAA6B9B,IAAI,CAACE,CCPzC,CDOO,ACPN6B,EDO4C,CAAtC,OCPI,CAACI,IAAD,CAAX,EAAmBH,SAAS,C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","file":"script.221c08a2.js","sourceRoot":"../playground","sourcesContent":["/** storage instance */\nexport const repositories = {};\n/** states instance */\nexport const states = {};\n/** middlewares list */\nexport const middlewares = {};\n/** store settings */\nexport const settings = {\n    strictMode: {},\n};","\nimport { settings } from './repositories';\n\n/** debuger list */\nexport const debugCollection = {};\n\n/**\n * Write log object\n * @param {string} message message\n * @param {string} repoName repository name\n */\nconst writeLog = function (type, message, repoName) {\n    if (Object.keys(debugCollection).length > 0) {\n        const line = this.stack.split('\\n')[1].split(':')[2];\n        createLog(\n            {\n                message: this.name + ': ' + message,\n                file: line,\n                level: repoName ? 'local' : 'global',\n                repo: repoName,\n                type,\n            },\n            repoName\n        );\n    }\n};\n\n/**\n * This method processes the storage logs\n * and outputs them to the debugger if necessary.\n * @param {any} data is error -> new Error, is warn -> string\n * @param {string} repoName repository name\n * @public\n */\nexport const createLog = function (data, repoName) {\n    for (const key in debugCollection) {\n        if (key === repoName) {\n            debugCollection[key](data);\n        }\n\n        if (!repoName) {\n            debugCollection[key](data);\n        }\n    }\n};\n\n/**\n * Create  log\n * @param {string} message message\n * @param {string} repoName repository name\n * @public\n */\nexport class Log extends Error {\n    constructor(message, repoName) {\n        super(message);\n        this.name = 'Biscuit log';\n        writeLog.call(this, 'log', message, repoName);\n    }\n}\n\n/**\n * Create warning log\n * @param {string} message message\n * @param {string} repoName repository name\n * @public\n */\nexport class Warning extends Error {\n    constructor(message, repoName) {\n        super(message);\n\n        if (settings.strictMode[repoName]) {\n            // eslint-disable-next-line no-console\n            console.warn(message);\n        }\n\n        this.name = 'Biscuit warn';\n        writeLog.call(this, 'warning', message, repoName);\n    }\n}\n\n/**\n * Create error log\n * @param {string} message message\n * @param {string} repoName repository name\n * @public\n */\nexport class CreateError extends Error {\n    constructor(message, repoName) {\n        super(message);\n        this.name = 'Biscuit error';\n        writeLog.call(this, 'error', message, repoName);\n    }\n}","\n/** debug messages */\nexport const messages = {\n    noRepo: (name) => `repository <${name}> not found.`,\n    noState: (name) => `state <${name}> not found.`,\n    initialType: 'The initial must be an object.',\n    noListener: 'The subscriber\\'s listener must be a function.',\n    noValidAction: 'An invalid dependencies was processed.',\n    storageNameError: (fnName) =>\n        `biscuit ${fnName} error: storage name is not a string.`,\n    noStoreParams:\n\t\t'The createStore method must contain the storage parameters.',\n    noRepoName: 'The repository name is a required field.',\n    middleNoFunc: 'Middleware should be provided as a feature.',\n    debuggerNoFunc: 'Debugger should be provided as a feature.',\n    actionString: 'The state name must be a string.',\n    repoNotFind: 'Repository not found.',\n    repoExists: 'A repository with this name already exists.',\n};","import { Warning, CreateError, Log } from './debugger';\nimport { messages } from './messages';\n/**\n * Module of the library responsible for creating tasks and subscribing to them.\n * @param  {string} action action name\n * @return {object} methods\n * @public\n */\nfunction createEmmitor() {\n    const taskBuffer = {};\n\n    return {\n        /**\n\t\t * This method allows you to subscribe to an action.\n\t\t * Creates a task that puts its own callback function,\n\t\t * which should then be started by the dispatcher\n\t\t * @param {string} stateName name of the state to subscribe to\n\t\t * @param {function} listener callback function\n\t\t * @param {string} state store state\n\t\t * @return {object{params: object, remove: function}} returned task id\n\t\t * @public\n\t\t */\n        subscribeAction: (taskName, listener, state) => {\n            if (typeof listener !== 'function') {\n                throw new CreateError(messages.noListener, taskName);\n            }\n\n            if (!taskBuffer[taskName]) {\n                taskBuffer[taskName] = [];\n            }\n            /** create task */\n            const task = {\n                state,\n                name: taskName,\n                todo: listener,\n                id: taskBuffer[taskName].length,\n            };\n            /** write task to buffer */\n            taskBuffer[task.name][task.id] = task;\n\n            new Log(`subscribe -> store: ${taskName}, state: ${state}`, taskName);\n            return {\n                /** task params */\n                params: task,\n                /**\n\t\t\t\t * Remove listner\n\t\t\t\t */\n                remove: () => {\n                    new Log(\n                        `unsubscribe -> store: ${task.name}, state: ${task.state}`,\n                        task.name\n                    );\n                    taskBuffer[task.name].splice(task.id, 1);\n                },\n            };\n        },\n\n        /**\n\t\t * This method allows you to subscribe to multiple actions.\n\t\t * Creates multiple tasks that run a single callback function.\n\t\t * @param {actions[object{repo: string, store: string}]} actions array actions\n\t\t * @param {function} listener callback\n\t\t * @return {}\n\t\t */\n        subscribeActions: (actions, listener) => {\n            if (typeof listener !== 'function') {\n                throw new CreateError(messages.noListener);\n            }\n\n            const tasks = [];\n            for (const action of actions) {\n                new Log(\n                    `subscribe -> store: ${action.repo}, state: ${action.state}`,\n                    action.repo\n                );\n\n                if (!action.repo) {\n                    throw new CreateError(messages.noValidAction);\n                }\n\n                if (!taskBuffer[action.repo]) {\n                    taskBuffer[action.repo] = [];\n                }\n                /** create task */\n                const task = {\n                    state: action.state,\n                    name: action.repo,\n                    todo: listener,\n                    id: taskBuffer[action.repo].length,\n                };\n                /** write task to buffer */\n                taskBuffer[task.name][task.id] = task;\n                /** write tasks to an array, for subsequent\n\t\t\t\t *  deletion via the remove method */\n                tasks.push(task);\n            }\n\n            return {\n                /** tasks array */\n                params: tasks,\n                /**\n\t\t\t\t * Remove listners\n\t\t\t\t */\n                remove: () => {\n                    for (const task of tasks) {\n                        new Log(\n                            `unsubscribe -> store: ${task.name}, state: ${task.state}`,\n                            task.name,\n                        );\n                        taskBuffer[task.name].splice(task.id, 1);\n                    }\n                },\n            };\n        },\n\n        /**\n\t\t * Starts all tasks that match the specified state name\n\t\t * and passes data to their callback functions.\n\t\t * @param {object{repo: string, state: string}} action action params\n\t\t * @async\n\t\t * @public\n\t\t */\n        dispatchAction: (action) => {\n            new Log(\n                `dispatch -> store: ${action.repo}, state: ${action.state}`,\n                action.repo\n            );\n\n            if (taskBuffer[action.repo]) {\n                taskBuffer[action.repo].forEach((task) => {\n                    /**\n\t\t\t\t\t * If the status field is not defined,\n\t\t\t\t\t * then run the task without additional checks, if the field is found,\n\t\t\t\t\t * then perform a state comparison\n\t\t\t\t\t */\n                    if (task.state === action.state) {\n                        task.todo(task);\n                    }\n\n                    if (task.state === undefined) {\n                        task.todo(task);\n                    }\n                });\n                return;\n            }\n\n            new Warning(\n                `store \"${action.repo}\" has no active subscriptions.`,\n                action.repo\n            );\n        },\n    };\n}\n\nexport const emitter = createEmmitor();","import { middlewares, states, repositories } from './repositories';\nimport { CreateError } from './debugger';\nimport { messages } from './messages';\n\nexport function getStateRepo(action) {\n    return states[`\"${action.state}\"`][action.repo];\n}\n\nexport function getRepository(name) {\n    return repositories[name].content;\n}\n\nexport function getRepositoryActions(repo) {\n    return repositories[repo].actions;\n}\n\nexport function getRepoName(target) {\n    if (typeof target === 'string') {\n        return target;\n    }\n\n    return target.repo;\n}\n\nexport const actionError = (action) => {\n    if (!action || !action.repo || !action.state) {\n        throw new CreateError('Invalid action parameters.');\n    }\n\n    if (!repositories[action.repo]) {\n        throw new CreateError(messages.noRepo(action.repo));\n    }\n\n    if (!states[`\"${action.state}\"`]) {\n        throw new CreateError(messages.noState(action.state), action.repo);\n    }\n};\n\n/**\n * Helper method for running middleware\n * @param {object} context handler context\n * @param {function} fn callback\n * @async\n * @private\n */\nexport async function activeMiddlewares(context, fn = () => null) {\n    if (middlewares[context.repo]) {\n        await middlewares[context.repo].forEach((middle) => {\n            middle(context, fn);\n        });\n    } else {\n        fn(context.payload);\n    }\n}\n\n/**\n * This method is used to get the values of the object without\n * the possibility of overwriting.\n * by attempting to write generates an error.\n * @param {object} instance object to extract\n * @return {object} returns a modified copy of the object\n * @private\n */\nexport function gettter(instance) {\n    return Object.freeze({ ...instance });\n}\n\n/**\n * Helper method for comparing two objects\n * Warning: can't compare methods\n * @param {object} firstState first object\n * @param {object} lastState last object\n * @return {bool}\n * @private\n */\nexport function compareObject(firstState, lastState) {\n    let propInFirst = 0;\n    let propInLast = 0;\n    let prop;\n\n    if (firstState === lastState) {\n        return true;\n    }\n\n    if (\n        firstState === null ||\n\t\ttypeof firstState !== 'object' ||\n\t\tlastState === null ||\n\t\ttypeof lastState !== 'object'\n    ) {\n        return false;\n    }\n\n    for (prop in firstState) {\n        propInFirst += 1;\n    }\n\n    for (prop in lastState) {\n        propInLast += 1;\n\n        if (\n            !(prop in firstState) ||\n\t\t\t!compareObject(firstState[prop], lastState[prop])\n        ) {\n            return false;\n        }\n    }\n\n    return propInFirst === propInLast;\n}","import { repositories } from './repositories';\nimport { activeMiddlewares, getStateRepo, getRepositoryActions } from './helper';\nimport { emitter } from './emitter';\nexport function dispatchProto({ action, prev, payData }) {\n    /**\n\t * Call before state change\n\t * @param {function} fn callback\n\t * @public\n\t */\n    this.before = (fn) => {\n        fn(prev);\n        return this;\n    };\n\n    /**\n\t * Merge state into repository\n\t * @public\n\t */\n    this.merge = () => {\n        repositories[action.repo].content = {\n            ...prev,\n            ...payData,\n        };\n\n        return this;\n    };\n\n    /**\n\t * Call after state change\n\t * @param {function} fn callback\n\t * @async\n\t * @public\n\t */\n    this.after = async (fn) => {\n        let task;\n        const call = function (resolve) {\n            resolve({\n                ...getStateRepo(action).content,\n            });\n            task.remove();\n        };\n\n        await new Promise((resolve) => {\n            task = emitter.subscribeAction(\n                action.repo,\n                () => call(resolve),\n                action.state\n            );\n        }).then(fn);\n        return this;\n    };\n}\n\nexport async function dispatchInitMiddleware({ action, payData, prev }) {\n    const actions = getRepositoryActions(action.repo);\n    return await new Promise((resolve) => {\n        activeMiddlewares(\n            {\n                action: action.state,\n                repo: action.repo,\n                payload: payData,\n                state: prev,\n                getAction: (actionName) => actions[`\"${actionName}\"`],\n            },\n            (newPayload) => {\n                resolve(newPayload || payData);\n            }\n        );\n    });\n}","/**\n * Creates a throttled function that only invokes func\n * at most once per every wait milliseconds.\n * @param {function} callback target function\n * @param {number} limit counter\n * @return {function}\n */\nexport function throttle(callback, limit) {\n    let waiting = false;\n    return function () {\n        if (!waiting) {\n            callback.apply(this, arguments);\n            waiting = true;\n            setTimeout(() => {\n                waiting = false;\n            }, limit);\n        }\n    };\n}\n\n/**\n * Creates a debounced function that delays invoking func\n * until after wait milliseconds have elapsed since\n * the last time the debounced function was invoked.\n * @param {function} callback target function\n * @param {number} limit counter\n * @return {function}\n */\nexport function debounce(callback, limit) {\n    let isCooldown = false;\n\n    return function () {\n        if (isCooldown) {\n            return;\n        }\n        callback.apply(this, arguments);\n        isCooldown = true;\n        setTimeout(() => isCooldown = false, limit);\n    };\n}\n\n/**\n * This method set allows you to. save the state of functions\n * tied to the timer. Required for the case when the timer\n * function is initialized in a method with a frequent call,\n * for example, in the react function component.\n * @param {function} fn target function\n*/\nexport const sandbox = (fn) => {\n    return {\n        run: (function () {\n            let throt = null;\n\n            /** initial run\n             * @param {function} call target function\n             * @param {number} timer timeout\n            */\n            const initialThrottle = (call, timer) => {\n                if (!throt) {\n                    throt = fn(call, timer);\n                }\n            };\n\n            /** initial run\n             * @param {args[any]} args arguments\n             * @return {function}\n             */\n            const throttleCaller = (...args) => {\n                return throt(...args);\n            };\n\n            /** initial\n            * @param {function} call target function\n            * @param {number} timer timeout\n            * @return {function} throttleCaller\n            */\n            return (call, timer) => {\n                initialThrottle(call, timer);\n                return throttleCaller;\n            };\n        })(),\n    };\n};\n\n/**\n * memoized function\n * @param {function} fn target function\n * @return {function}\n*/\nexport const memoize = (fn) => {\n    const cache = {};\n    return (...args) => {\n        const n = args[0];\n        if (n in cache) {\n            return cache[n];\n        } else {\n            const result = fn(n);\n            cache[n] = result;\n            return result;\n        }\n    };\n};\n\n/**\n * Strict type checking\n * @param {*} value any value\n */\nexport function type(value) {\n    const regex = /^\\[object (\\S+?)]$/;\n    const matches = Object.prototype.toString.call(value).match(regex) || [];\n    return (matches[1] || 'undefined').toLowerCase();\n}\n","import {\n    repositories,\n    states,\n} from './repositories';\nimport {\n    emitter,\n} from './emitter';\nimport {\n    gettter,\n    getStateRepo,\n    getRepository,\n    compareObject,\n    actionError,\n    getRepoName,\n} from './helper';\nimport { dispatchProto, dispatchInitMiddleware } from './dispatch';\nimport { CreateError } from './debugger';\nimport { type } from './utils';\nimport { messages } from './messages';\nimport { newRepo } from './creator';\n/**\n * Allows you to subscribe to the store. and tracks its change.\n * @param {string} repo repository name\n * @param {function} fn callback\n * @param {string} state state name\n * @return {Promise}\n * @async\n */\nconst subscriber = function (repo, fn, state) {\n    let task;\n    const promise = new Promise((resolve) => {\n        task = emitter.subscribeAction(repo, () => {\n            /** if there is a state then pick it up */\n            const data = state\n                ? getState({ repo, state })\n                : getRepo(repo);\n            fn(data, task);\n            resolve({ data });\n        }, state);\n    });\n\n    const resolve = this.resolve(promise);\n    resolve['unsubscribe'] = task.remove;\n\n    return resolve;\n};\n\n/**\n * This method allows you to add new values to the repository.\n * Accepts the storage name and object.\n * @param {string | import('../../../types').Store} target repository name or store\n * @param {object} instance object with added data\n * @public\n */\nexport function addRepo(target, instance) {\n    const name = getRepoName(target);\n    if (!repositories[name]) {\n        throw new CreateError(messages.noRepo(name));\n    }\n\n    if (type(instance) !== 'object') {\n        throw new CreateError(messages.initialType);\n    }\n\n    repositories[name].content = {\n        ...getRepository(name),\n        ...instance,\n    };\n}\n\n/**\n * This method is used to get data from the storage by its key.\n * Warning: Storage data cannot be changed directly.\n * You can replace the values either with the \"addRepo\"\n * method or with state injection via \"manager\".\n * @param {string | import('../../../types').Store} target repository name or store\n * @return {object} storage data\n * @public\n */\nexport function getRepo(target) {\n    const name = getRepoName(target);\n\n    if (!repositories[name]) {\n        throw new CreateError(messages.noRepo(name));\n    }\n\n    return gettter({ ...getRepository(name) });\n}\n\n/**\n * This method is needed to get the storage state\n * Warning: Storage data cannot be changed directly.\n * You can replace the values either with the \"dispatch (...)\"\n * method or with an implementation via \"manager\".\n * @param {import('../../types/state').AnyAction} action the parameters of the action\n * @return {object} state data\n * @public\n */\nexport function getState(action) {\n    actionError(action);\n    return gettter({ ...getStateRepo(action).content });\n}\n\n/**\n * This is one of the most important methods.\n * allows you to asynchronously update and change the state of the storage.\n *\n * The first argument accepts action parameters,\n * the second argument accepts an object with new data\n * or a callback function that returns the past state\n * as an argument and returns a new state.\n *\n * Dispatch also returns several methods for working with states.\n * @param {import('../../types/state').AnyAction} action the parameters of the action\n * @param {object | import('../../types/state').DispatchPayload} payload\n * payload data or callback function\n * @return {import('../../types/state').Dispatcher}\n * returns methods: before, after, merge\n * @async\n * @public\n */\nexport function dispatch(action, payload = {}) {\n    const voids = {};\n\n    actionError(action);\n\n    if (type(payload) !== 'function' && type(payload) !== 'object') {\n        throw new CreateError('The payload must be an object or function.', action.repo);\n    }\n\n    async function promise() {\n        const state = getStateRepo(action);\n        const prev = { ...state.content };\n\n        /** if the function\n         * then pass the current state to the callback  */\n        let payData = typeof payload === 'function'\n            ? payload(prev)\n            : payload;\n\n        dispatchProto.call(voids, {\n            action,\n            prev,\n            payData,\n        });\n\n        /** initial middlewares */\n        payData = await dispatchInitMiddleware({ action, payData, prev });\n\n        /** update state data */\n        getStateRepo(action).content = {\n            ...state.content,\n            ...payData,\n        };\n\n        /** create dispatch action */\n        emitter.dispatchAction(action);\n        return true;\n    };\n\n    const task = promise();\n\n    return { wait: task, ...voids };\n}\n\n/**\n * This is one of the most important methods.\n * Allows you to subscribe to the state. and tracks its change.\n * The first argument takes the parameters of the action.\n * results can be obtained through the callback of the second\n * argument or through the return promise.\n * @param {import('../../types/state').AnyAction} action the parameters of the action\n * @param {import('../../types/subscribe').SubscribeListner} fn callback\n * @return {Promise<any>}\n * @async\n * @public\n */\nexport function subscribeToState(action, fn = () => undefined) {\n    const that = Promise;\n    try {\n        actionError(action);\n        return subscriber.call(that, action.repo, fn, action.state);\n    } catch (e) {\n        return that.reject(e);\n    }\n}\n\n/**\n * This is one of the most important methods.\n * Allows you to subscribe to the store. and tracks its change.\n * The first argument takes the name store.\n * results can be obtained through the callback of the\n * second argument or through the return promise.\n * @param {string | import('../../../types').Store} target repository name or store\n * @param {import('../../types/state').SubscribeListner} fn callback\n * @callback\n * @async\n * @public\n */\nexport function subscribeToStore(target, fn = () => undefined) {\n    const repo = getRepoName(target);\n    const that = Promise;\n    try {\n        if (!repositories[repo]) {\n            throw new CreateError(messages.noRepo(repo));\n        }\n\n        return subscriber.call(that, repo, fn);\n    } catch (e) {\n        return that.reject(e);\n    }\n}\n\n/**\n * The State Manager allows you to manage the storage and its state.\n * Provides a set of methods for two-way merge, replace, copy,\n * and other actions between the selected storage and state.\n * @param {import('../../types/state').AnyAction} action the parameters of the action\n * @return {object} returns a set of methods\n * @public\n */\nexport function createManager(action) {\n    actionError(action);\n    return {\n        /**\n         * This method will combine data from the state with data from the storage.\n         * @public\n         */\n        merge: () => {\n            repositories[action.repo].content = {\n                ...getRepository(action.repo),\n                ...getStateRepo(action).content,\n            };\n        },\n\n        /**\n         * This method will merge data from the storage with data from the state.\n         * @public\n         */\n        pull: () => {\n            getStateRepo(action).content = {\n                ...getStateRepo(action).content,\n                ...getRepository(action.repo),\n            };\n        },\n\n        /**\n         * This method will replace the data from the storage with state data.\n         * @public\n         */\n        replaceRepo: () => {\n            repositories[action.repo].content = {\n                ...getStateRepo(action).content,\n            };\n        },\n\n        /**\n         * This method will replace the data from the state with the storage data.\n         * @public\n         */\n        replaceState: () => {\n            getStateRepo(action).content = {\n                ...getRepository(action.repo),\n            };\n        },\n\n        /**\n         * This method will merge the data of the selected state\n         * with the data of the state specified in the arguments.\n         * @param {import('../../types/state').AnyAction} targetAction\n         * the action that you want to merge\n         * @public\n         */\n        mergeState: (targetAction) => {\n            actionError(targetAction);\n            getStateRepo(action).content = {\n                ...getStateRepo({\n                    state: targetAction.state,\n                    repo: action.repo,\n                }).content,\n                ...getStateRepo(action).content,\n            };\n        },\n\n        /**\n         * This method removes the storage and its copies from all states.\n         * WARNING: This method can be useful for optimization,\n         * but it can make the code non-obvious,\n         * which will lead to difficulties in support.\n         * @public\n         */\n        remove: () => {\n            delete repositories[action.repo];\n            Object.keys(states[`\"${action.state}\"`]).forEach((item) => {\n                if (item === action.repo) {\n                    delete states[`\"${action.state}\"`][action.repo];\n                }\n            });\n        },\n\n        /**\n         * This method compares two states\n         * WARNING: states should not contain methods\n         * @param {import('../../types/state').AnyAction} targetAction\n         * the action that you want to compare\n         * @return {bool}\n         * @public\n         */\n        compareStates: (targetAction) => {\n            actionError(targetAction);\n            return compareObject(\n                getStateRepo(action).content,\n                getStateRepo(targetAction).content,\n            );\n        },\n\n        /**\n         * Сompare state and repository\n         * WARNING: states should not contain methods\n         * @return {bool}\n         * @public\n         */\n        compareWithState: () => {\n            return compareObject(\n                getRepository(action.repo),\n                getStateRepo(action).content\n            );\n        },\n\n        /**\n         * compare state and instance object\n         * WARNING: states should not contain methods\n         * @param {object} instance object instance\n         * @return {bool}\n         * @public\n         */\n        compareStateWithInstance: (instance) => {\n            return compareObject(getStateRepo(action).content, instance);\n        },\n\n        /**\n         * \\\n         * WARNING: states should not contain methods\n         * @param {object} instance object instance\n         * @return {bool}\n         * @public\n         */\n        compareRepoWithInstance: (instance) => {\n            return compareObject(getRepository(action.repo), instance);\n        },\n\n        /**\n         * Clones the selected storage and its state.\n         * WARNING: It is best to avoid using this method,\n         * as the best practice would be to do initialization of repositories in one place.\n         * Copying the repository can lead to code support difficulties.\n         * @param {string} name name for the new storage\n         * @public\n         */\n        clone: (name) => {\n            const repo = newRepo(name, { ...getRepository(action.repo) });\n            states[`\"${action.state}\"`][name] = {\n                content: { ...getStateRepo(action).content },\n            };\n\n            return repo;\n        },\n\n        /**\n         * Updates the status of the repository.\n         * This method is equivalent to dispatch(...)\n         * @public\n         */\n        update: () => {\n            dispatch(action, {});\n        },\n\n        /**\n         * Returns parameters of the selected action\n         * @public\n         */\n        props: action,\n    };\n}\n","import { debugCollection, CreateError } from './debugger';\nimport {\n    repositories,\n    states,\n    middlewares,\n    settings,\n} from './repositories';\n\nimport {\n    dispatch,\n    subscribeToState,\n    getState,\n    getRepo,\n    subscribeToStore,\n    addRepo,\n} from './store';\nimport { type } from './utils';\nimport { actionError } from './helper';\nimport { messages } from './messages';\n\n/**\n * This method is responsible for creating a new repository.\n * Takes as the first argument a string with the repository name.\n * and the initial state of the storage as the second argument\n * @param {string} name storage name\n * @param {import('../../types/store').Store} initial initial object\n * @public\n */\nexport function newRepo(name, initial = {}) {\n    if (!name) {\n        throw new CreateError(messages.noRepoName);\n    }\n\n    if (typeof name !== 'string') {\n        throw new CreateError(messages.storageNameError('newRepo'));\n    }\n\n    if (type(initial) !== 'object') {\n        throw new CreateError(messages.initialType, name);\n    }\n\n    repositories[name] = { content: initial, actions: {} };\n\n    return {\n        repo: name,\n        /** Subscribe by change @param {function} fn */\n        subscribe: (fn) => subscribeToStore(name, fn),\n        /** get reposiory */\n        get: () => getRepo(name),\n        /** add to reposiory @param {object} instance */\n        add: (instance) => addRepo(name, instance),\n    };\n}\n\n/**\n * This method binds states to the storage via the \"add\" method.\n * Gets the storage name string as an argument.\n * @param {import('../../types/store').Store} params name of the linked storage\n * @return {import('../../types/state').ActionCreator} returns the \"add\" method\n * @public\n */\nexport function createStateTo(params) {\n    if (!repositories[params.repo]) {\n        throw new CreateError(messages.repoNotFind);\n    }\n\n    const createNewState = (stns) => {\n        if (!stns.branch) {\n            return repositories[params.repo];\n        }\n\n        return {\n            content: {\n                ...repositories[params.repo].content,\n                ...stns.initial,\n            },\n        };\n    };\n\n    return {\n        /** This method binds the state to the selected storagee\n\t\t * @param {string} action state name\n         * @param {import('../../types/state').StateOptions} options state options\n         * @return {import('../../types/state').StateAction}\n\t\t * @public\n\t\t */\n        bind: (action, options = { branch: false, initial: {} }) => {\n            if (typeof action !== 'string') {\n                throw new CreateError(messages.actionString, params.repo);\n            }\n\n            const actionStr = `\"${action}\"`;\n\n            states[actionStr] = {\n                ...states[actionStr],\n                [params.repo]: createNewState(options),\n            };\n\n            const actionParams = {\n                repo: params.repo,\n                state: action,\n            };\n\n            const returnedParams = {\n                ...actionParams,\n                /**\n\t\t\t\t * Update state\n\t\t\t\t * @param {import('../../types/state').DispatchPayload} payload\n\t\t\t\t * @public\n\t\t\t\t */\n                dispatch: (payload = {}) => dispatch(actionParams, payload),\n                /**\n\t\t\t\t * Subscribe to state\n\t\t\t\t * @param {import('../../types/subscribe').SubscribeListner} fn callback\n\t\t\t\t * @public\n\t\t\t\t */\n                subscribe: (fn) => subscribeToState(actionParams, fn),\n\n                /**\n\t\t\t\t * Get state\n\t\t\t\t * @public\n\t\t\t\t */\n                getState: () => getState(actionParams),\n            };\n\n            repositories[params.repo].actions[`\"${action}\"`] = returnedParams;\n            return returnedParams;\n        },\n        /** repository key */\n        repo: params.repo,\n    };\n}\n\n/**\n * This helper method takes the first parameter \"createactionsTo\"\n * and adds actions to it from the string array of the second argument.\n * @param {import('../../types/state').ActionCreator} createActions\n * createactionsto(storage name) method\n * @param {array[string]} actions actions string array\n * @return {{import('../types/state').StateAction}[]} actions\n * @public\n */\nexport function initialActions(createActions, actions) {\n    return actions.map((item) => {\n        const args = typeof item === 'string'\n            ? [item]\n            : [item.name, item.options];\n\n        return createActions.bind.apply(null, args);\n    });\n}\n\n/**\n * This helper method converts the actions received via the argument to an array\n * @return {import('../../types/state').StateCollection} returns the \"compile\" method\n * @public\n */\nexport function stateCollection() {\n    const collection = {};\n    return {\n        /**\n\t\t * compile state collection\n\t\t * @return {import('../../types/state').StateCollectionRepo} actions collection\n\t\t * @public\n\t\t */\n        compile: (...actions) => {\n            for (let action of actions) {\n                actionError(action);\n\n                if (!collection[action.repo]) {\n                    collection[action.repo] = [{ ...action }];\n                    continue;\n                }\n\n                collection[action.repo].push({ ...action });\n\n            }\n\n            return { ...collection };\n        },\n        /**\n         * Get the entire collection actions\n         * @return {import('../../types/state').StateCollectionRepo} collections instance\n         * @public\n         */\n        all: () => ({ ...collection }),\n\n        /**\n         * Get a collection by matching the storage name\n         * @param {string} repo storage name\n         * @return {import('../../types/state').StateAction[]} collections instance\n         * @public\n         */\n        fromRepo: (repo) => [ ...collection[repo] ],\n\n        /**\n         * Get the result filtered by state name\n         * @param {string} stateName state name\n         * @return {import('../../types/state').StateAction[]} state list\n         * @public\n         */\n        outOfState: (stateName) => {\n            let out = null;\n            Object.keys(collection).forEach((key) => {\n                out = collection[key].filter(({ state }) => state === stateName);\n            });\n\n            return out;\n        },\n    };\n}\n\n/**\n * This helper method can combine multiple collections of actions.\n * Accepts \"stateCollection(...action)\"\n * @param {import('../../types/state').StateCollection} collection array StateCollection\n * @public\n */\nexport function combineStateCollections(...collections) {\n    let allState = [];\n    for (let collection of collections) {\n        Object.keys(collection.all()).forEach((repoName) => {\n            allState = [ ...allState, ...collection.fromRepo(repoName) ];\n        });\n    }\n\n    const sc = stateCollection();\n    sc.compile.apply(null, allState);\n    return sc;\n}\n\n/**\n * This method allows you to add middleware for the state handler.\n * @param {import('../../types/store').Store} store the store params\n * @return {import('../../types/store').MiddlewareParams} returns a set of methods\n * @public\n */\nexport function middleware(store) {\n    if (!repositories[store.repo]) {\n        throw new CreateError(messages.noRepo(store.repo));\n    }\n\n    const s = store.repo;\n    return {\n        /**\n\t\t * Adds a handler to the middleware task list.\n\t\t * @param {function} fn middle function\n\t\t * @public\n\t\t */\n        add: (fn) => {\n            if (typeof fn !== 'function') {\n                throw new CreateError(messages.middleNoFunc, s);\n            }\n\n            if (middlewares[s]) {\n                middlewares[s].push(fn);\n            } else {\n                middlewares[s] = [fn];\n            }\n        },\n    };\n}\n\n/**\n * This method allows you to add your own debugger.\n * The debugger will accept and output logs instead of the standard debugger.\n * @param {import('../../types/store').Store} store store object\n * @param {import('../../types/store').DebuggerListener} fn debugger callback function\n * @public\n */\nexport function createDebuger(store, fn) {\n    if (!repositories[store.repo]) {\n        throw new CreateError(messages.noRepo(store.repo));\n    }\n\n    if (typeof fn !== 'function') {\n        throw new CreateError(messages.debuggerNoFunc);\n    }\n\n    debugCollection[store.repo] = fn;\n}\n\n/**\n * Monolithic method for creating a biscuit storage.\n * This is the preferred method for creating a repository.\n * @param {import('../../types/store').StoreSettings} options\n * an object containing the store settings\n * @return {import('../../types/store').StoreParams}\n * returns a set of actions\n * @public\n */\nexport function createStore(options) {\n    if (!options) {\n        throw new CreateError(messages.noStoreParams);\n    }\n\n    /** DefaultParams */\n    const params = { strictMode: true, ...options };\n\n    /** Create a new storage */\n    const repo = newRepo(params.repo.name, params.repo.initial);\n    const createAction = createStateTo(repo);\n\n    /** Set of storage parameters */\n    const output = {\n        store: { ...repo },\n        actions: {},\n    };\n\n    /** Adding States to the repository */\n    if (params.states) {\n        for (const key in params.states) {\n            const param = params.states[key];\n            const paramType = typeof param === 'string';\n            output.actions[key] = createAction.bind(\n                paramType ? param : param.name,\n                paramType\n                    ? {}\n                    : { initial: param.initial, branch: param.branch }\n            );\n        }\n    }\n\n    /** Adding middleware to the repository */\n    if (params.middleware && params.middleware.length > 0) {\n        const middle = middleware(repo);\n        for (const fn of params.middleware) {\n            middle.add(fn);\n        }\n    }\n\n    /** Adding debuger to the repository */\n    if (params.debugger) {\n        createDebuger(repo, params.debugger);\n    }\n\n    /** Strict mod */\n    settings.strictMode[params.repo.name] = params.strictMode;\n\n    return output;\n}","export {\n    createStore,\n    newRepo,\n    createStateTo,\n    initialActions,\n    stateCollection,\n    combineStateCollections,\n    middleware,\n    createDebuger,\n} from './internal/creator';\n\nexport {\n    createManager,\n    dispatch,\n    getRepo,\n    getState,\n    addRepo,\n    subscribeToState,\n    subscribeToStore,\n} from './internal/store';\n","/* eslint-disable no-console */\nimport {\n    createStore,\n} from '../packages/biscuit-store';\n\n\nconst { actions } = createStore({\n    repo: {\n        name: 'user',\n        initial: { value: 0 },\n    },\n    states: {\n        testAdd: 'TEST/ADD',\n        testRemove: 'TEST/REMOVE',\n        testStep: {\n            name: 'TEST/STEP',\n            branch: true,\n            initial: { name: 'fill' },\n        },\n    },\n});\n\nconst { testAdd } = actions;\n\ntestAdd.subscribe((state) => {\n    console.log(state);\n});\n\n(async function () {\n    const arr = new Array(5).fill(1);\n    for (let key of arr) {\n        await testAdd.dispatch((prev) => ({ value: prev.value + key })).wait;\n    }\n}());\n"]}